<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="————–API第一天————– Object: 它是所有类的超类，祖宗类        java中所有的类都直接或间接的继承这个类    方法(都要了解)        public int hashCode() 返回当前对象的哈希码值，理解为对象的地址值        public String toString() 返回当前对象中的内容, 对于Object类默认操作来说，返回的">
<meta property="og:type" content="article">
<meta property="og:title" content="基础知识总结">
<meta property="og:url" content="http://yoursite.com/2016/05/02/基础知识/index.html">
<meta property="og:site_name" content="Big Elephant">
<meta property="og:description" content="————–API第一天————– Object: 它是所有类的超类，祖宗类        java中所有的类都直接或间接的继承这个类    方法(都要了解)        public int hashCode() 返回当前对象的哈希码值，理解为对象的地址值        public String toString() 返回当前对象中的内容, 对于Object类默认操作来说，返回的">
<meta property="og:updated_time" content="2017-07-26T08:36:25.636Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="基础知识总结">
<meta name="twitter:description" content="————–API第一天————– Object: 它是所有类的超类，祖宗类        java中所有的类都直接或间接的继承这个类    方法(都要了解)        public int hashCode() 返回当前对象的哈希码值，理解为对象的地址值        public String toString() 返回当前对象中的内容, 对于Object类默认操作来说，返回的">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2016/05/02/基础知识/"/>





  <title>基础知识总结 | Big Elephant</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Big Elephant</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/05/02/基础知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cuidx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Big Elephant">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">基础知识总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-02T00:00:00+08:00">
                2016-05-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/基础/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>————–API第一天————–</p>
<p>Object: 它是所有类的超类，祖宗类<br>        java中所有的类都直接或间接的继承这个类<br>    方法(都要了解)<br>        public int hashCode() 返回当前对象的哈希码值，理解为对象的地址值<br>        public String toString() 返回当前对象中的内容, 对于Object类默认操作来说，返回的<br>                  包名.类名@哈希码值<br>        public boolean equals(Object obj) 比较两个对象内容是否相同，<br>                对于Object类默认操作来说,比较的是地址值</p>
<p>String: 字符串类(重点)<br>        字符串是常量；它们的值在创建之后不能更改</p>
<pre><code>构造方法：(掌握,重点是能知道什么意思)
    public String() 空参数构造方法
    public String(String original) 就是字符串字面值，封装成对象  
    //下面方法做为一个了解...因为会在以后IO的代码中会看到使用
      public String(byte[] bytes) 把字节数组转换字符串
     public String(byte[] bytes, int startIndex,  int length) 把字节数组一部分元素 转换成字符串
      public String(char[] value) 把字符数组 转换成字符串
      public String(char[] value, int startIndex, int count) 把字符数组一部分元素 转换成字符串
</code></pre><p> 方法：<br>    判断功能()<br>        boolean equals(Object obj) 判断两个字符串中的内容是否相同<br>        boolean equalsIgnoreCase(String str)  判断两个字符串中的内容是否相同, 忽略大小写<br>        boolean contains(String str) 判断该字符串中 是否包含给定的字符串<br>        boolean startsWith(String str) 判断该字符串 是否以给定的字符串开头<br>        boolean endsWith(String str) 判断该字符串 是否以给定的字符串结尾<br>        boolean isEmpty() 判断该字符串的内容是否为空的字符串  “” </p>
<pre><code>获取功能：
    int length() 获取该字符串的长度
    char charAt(int index) 获取该字符串中指定位置上的字符 
    String substring(int start) 从指定位置开始，到末尾结束，截取该字符串，返回新字符串
    String substring(int start,int end) 从指定位置开始，到指定位置结束，截取该字符串，返回新字符串 
    //下面是关于索引的一些查询  这个不作为掌握 但是要了解字符串中有这样的功能
    int indexOf(int ch ) 获取给定的字符，在该字符串中第一次出现的位置
    int indexOf(String str) 获取给定的字符串，在该字符串中第一次出现的位置
    int indexOf(int ch,int fromIndex) 从指定位置开始，获取给定的字符，在该字符串中第一次出现的位置
    int indexOf(String str,int fromIndex) 从指定位置开始，获取给定的字符串，在该字符串中第一次出现的位置

转换功能：
    byte[] getBytes() 把该字符串 转换成 字节数组
    char[] toCharArray() 把该字符串 转换成 字符数组

    //下面的方法 知道有就可以了
    String toLowerCase() 把该字符串转换成 小写字符串 
    String toUpperCase() 把该字符串转换成 大写字符串

    String concat(String str) 把该字符串与给定的字符串相连接，返回一个新的字符串

替换功能
    String replace(char old,char new) 在该字符串中，将给定的旧字符，用新字符替换
    String replace(String old,String new) 在该字符串中， 将给定的旧字符串，用新字符串替换
去除字符串两空格    
    String trim() 去除字符串两端空格，中间的不会去除，返回一个新字符串
</code></pre><p>StringBuffer/StringBuilder:(理解)<br>    构造方法：<br>        public StringBuffer() 创建一个字符串缓冲区，默认容量大小16<br>        public StringBuffer(String str) 创建一个字符串缓冲区，指定默认内容为 str 的内容，长度为 字符串str的长度 + 16<br>    方法：<br>        public StringBuffer append(String str) 在原有字符串缓冲区内容基础上，在末尾追加新数据<br>        public StringBuffer insert(int offset,String str) 在原有字符串缓冲区内容基础上，在指定位置插入新数据<br>        public StringBuffer deleteCharAt(int index) 在原有字符串缓冲区内容基础上，删除指定位置上的字符<br>        public StringBuffer delete(int start,int end) 在原有字符串缓冲区内容基础上，删除指定范围内的多个字符<br>        public StringBuffer replace(int start,int end,String str)在原有字符串缓冲区内容基础上，将指定范围内的多个字符 用给定的字符串替换</p>
<pre><code>-----------------------------
public StringBuffer reverse() 将字符串缓冲区的内容 反转  &quot;abc&quot;----&quot;cba&quot;
public String substring(int start) 从指定位置开始，到末尾结束，截取该字符串缓冲区，返回新字符串
public String substring(int start,int end)  从指定位置开始，到指定位置结束，截取该字符串缓冲区，返回新字符串 
</code></pre><p>————–API第二天————–<br>正则表达式:<br>    (1)就是符合一定规则的字符串<br>    (2)常见规则<br>        A:字符<br>            x 字符 x。举例：”a”表示字符a<br>            \ 反斜线字符。<br>            \n 新行（换行）符<br>            \r 回车符 </p>
<pre><code>    B:字符类
        [abc] a、b 或 c（简单类） 
        [^abc] 任何字符，除了 a、b 或 c（否定） 
        [a-zA-Z] a到 z 或 A到 Z，两头的字母包括在内（范围） 
        [0-9] 0到9的字符都包括

    C:预定义字符类
        . 任何字符。我的就是.字符本身，怎么表示呢? \.
        \d 数字：[0-9]
        \w 单词字符：[a-zA-Z_0-9]
            在正则表达式里面组成单词的东西必须有这些东西组成

    D:边界匹配器
        ^ 行的开头 
        $ 行的结尾 
        \b 单词边界
            就是不是单词字符的地方。
            举例：hello world?haha;xixi

    E:Greedy 数量词 
        X? X，一次或一次也没有
        X* X，零次或多次
        X+ X，一次或多次
        X{n} X，恰好 n 次 
        X{n,} X，至少 n 次 
        X{n,m} X，至少 n 次，但是不超过 m 次 
(3)常见功能：
    A:判断功能
        String类的
        public boolean matches(String regex) 进行字符串规则的匹配
    B:分割功能
        String类的
        public String[] split(String regex)  字符串按照某种规则进行切割
    C:替换功能
        String类的
        public String replaceAll(String regex,String replacement) 字符串按照某种规则替换小串

(4)案例
    A:判断电话号码和邮箱
    B:按照不同的规则分割数据
    C:把论坛中的数字替换为*
</code></pre><p>Date/DateFormat<br>    (1)Date是日期类，可以精确到毫秒。<br>        A:构造方法<br>            Date()  获取当前时间<br>            Date(long time)  获取0点时间+毫秒值的新时间<br>        B:成员方法<br>            getTime() 获取日期对象对应的毫秒值<br>            setTime(long time) 设置日期对象的时间毫秒值<br>        C:日期和毫秒值的相互转换</p>
<pre><code>案例：你来到这个世界多少天了?

(2)DateFormat针对日期进行格式化和针对字符串进行解析的类，但是是抽象类，所以使用其子类SimpleDateFormat
    A:SimpleDateFormat(String pattern) 给定模式
        yyyy-MM-dd HH:mm:ss
    B:日期和字符串的转换
        a:Date -- String   日期对象转换成 字符串
            format()

        b:String -- Date   字符串转换成日期对象
            parse()
</code></pre><p>Calendar<br>    (1)日历类，封装了所有的日历字段值，通过统一的方法根据传入不同的日历字段可以获取值。<br>    (2)如何得到一个日历对象呢?<br>        Calendar rightNow = Calendar.getInstance();<br>        本质返回的是子类对象<br>    (3)成员方法<br>        A:根据日历字段得到对应的值<br>        B:根据日历字段和一个正负数确定是添加还是减去对应日历字段的值<br>        C:设置日历对象的年月日</p>
<p>————–API第三天————–<br>为了让基本类型的数据进行更多的操作，Java就为每种基本类型提供了对应的包装类类型<br>        byte         Byte<br>        short        Short<br>        int            Integer<br>        long        Long<br>        float        Float<br>        double        Double<br>        char        Character<br>        boolean        Boolean<br>Integer:<br>    构造方法：<br>        public Integer(int value) 把基本数据类型int值 ， 封装成对象<br>        public Integer(String s)  把字符串类型的数字字符，封装成对象<br>    方法：<br>        //要知道Integer中有进制转换的方法 将来使用 去找就可以了  完全不用记忆<br>        public static String toBinaryString(int i) 10进制 –&gt; 2进制<br>        public static String toOctalString(int i) 10进制 –&gt; 8进制<br>        public static String toHexString(int i) 10进制 –&gt; 16进制<br>        public static String toString(int i,int radix) 10进制 –&gt; x进制<br>        public static int parseInt(String s,int radix) x进制 –&gt; 10进制</p>
<pre><code>  //--------------------------------------------
  public String toString() 把Integer中的数值 转换成 字符串   Integer --&gt; String
  public static String toString(int i) 把基本数据类型 int值 转成 字符串      int --&gt; String
  public int intValue() 把Integer中的数值 获取出来， 返回一个基本数据类型 int 值  Integer --&gt; int
            (我们自动拆箱中 调用的方法)
  public static int parseInt(String s) String --&gt; int
  public static Integer valueOf(String s) String --&gt;Integer 

 JDK5的新特性
   自动装箱    基本类型--引用类型  Integer ii = new Integer(100)
                                  Integer ii = Integer.valueOf(100);
                     自动装箱     Integer ii = 100; 
                     自动装箱中隐含 这这么一句话  Integer.valueOf(100);
   自动拆箱    引用类型--基本类型  int i = ii.intValue();
                     自动拆箱     int i = ii; //隐含了上面那句话

再次提到 toString()和equals()都只能由对象调用 
   如果说某一个类 直接打印对象的时候  
                      打印的是地址值    调用的是 Object的toString() 没有重写
                      打印的是对象内容  重写了toString()方法
   如果说 对象 调用了equals方法  
                      发现 比较的还是地址值,说明该类没有重写equals方法
                      发现 比较的对象中内容,说明该类重写了equals方法

  把下面的这个代码理解即可：
      Integer i = 100;
      i += 200;
面试题
  注意是在自动装箱中隐含 这这么一句话  Integer.valueOf(数值);
  -128到127之间的数据缓冲池问题

Character 比较特殊 没有parseXXX功能  
  String 对象 
   &quot;a&quot;.charAt(0)   将String变成char类型
</code></pre><hr>
<p>Math: 数学工具类<br>    public static double max(double a, double b)返回两个 double 值中较大的一个<br>    public static double min(double a, double b)返回两个 double 值中较小的一个<br>    public static double random() 返回 0.0&lt;=x&lt;1.0 之间的随机小数<br>    public static long round(double a) 四舍五入</p>
<p>System:<br>    方法：<br>        <em>public static void exit(int status)<br>            终止当前正在运行的 Java 虚拟机。参数用作状态码；根据惯例，非 0 的状态码表示异常终止
        </em>public static long currentTimeMillis()<br>            返回当前系统时间的毫秒值<br>      public static void gc()<br>            用来运行JVM中的垃圾回收器，完成内存中垃圾的清除。<br>      public static String getProperty(String key)<br>            用来获取指定键(字符串名称)中所记录的系统属性信息<br>        arraycopy方法，用来实现将源数组部分元素复制到目标数组的指定位置(知道有,能简单使用就行)</p>
<p>数组高级以及Arrays<br>    (1)排序<br>        A:冒泡排序<br>            相邻元素两两比较，大的往后放，第一次完毕，最大值出现在了最大索引处。<br>            同理，其他的元素就可以排好。</p>
<pre><code>        public static void bubbleSort(int[] arr) {
            for(int x=0; x&lt;arr.length-1; x++) {
                for(int y=0; y&lt;arr.length-1-x; y++) {
                    if(arr[y] &gt; arr[y+1]) {
                        int temp = arr[y];
                        arr[y] = arr[y+1];
                        arr[y+1] = temp;
                    }
                }
            }
        }

    B:选择排序
        把0索引的元素，和索引1以后的元素都进行比较，第一次完毕，最小值出现在了0索引。
        同理，其他的元素就可以排好。

        public static void selectSort(int[] arr) {
            for(int x=0; x&lt;arr.length-1; x++) {
                for(int y=x+1; y&lt;arr.length; y++) {
                    if(arr[y] &lt; arr[x]) {
                        int temp = arr[x];
                        arr[x] = arr[y];
                        arr[y] = temp;
                    }
                }
            }
        }
(2)查找
    A:基本查找
        针对数组无序的情况

        public static int getIndex(int[] arr,int value) {
            int index = -1;

            for(int x=0; x&lt;arr.length; x++) {
                if(arr[x] == value) {
                    index = x;
                    break;
                }
            }

            return index;
        }
    B:二分查找(折半查找)
        针对数组有序的情况

        public static int binarySearch(int[] arr,int value) {
            int min = 0;
            int max = arr.length-1;
            int mid = -1;

            while(min&lt;=max) {

                mid = (min+max)/2;

                if(arr[mid] &gt; value) {
                    max = mid - 1;
                }else if(arr[mid] &lt; value) {
                    min = mid + 1;
                }else{
                    return mid;
                }    

            }

            return mid;
        }
(3)Arrays 工具类
    A:是针对数组进行操作的工具类。包括排序和查找等功能。
    B:要掌握的方法
        public static void sort(数组)用来对指定数组中的元素进行排序（元素值从小到大进行排序
        public static int binarySearch(int[] arr,int key)在指定数组中，查找给定元素值出现的位置。若没有查询到，返回位置为负数
        public static String toString(数组)用来返回指定数组元素内容的字符串形式
</code></pre><p>———————-集合第一天—————————-<br>集合(Collection)(掌握)<br>    集合的由来?<br>        我们学习的是Java – 面向对象 – 操作很多对象 – 存储 – 容器 – 数组<br>        而数组的长度固定，所以不适合做变化的需求，Java就提供了集合供我们使用。<br>    集合和数组的区别?<br>        A:长度区别<br>            数组固定<br>            集合可变<br>        B:内容区别<br>            数组可以是基本类型，也可以是引用类型<br>            集合只能是引用类型<br>        C:元素内容<br>            数组只能存储同一种类型<br>            集合可以存储不同类型(其实集合一般存储的也是同一种类型)<br>    集合的继承体系结构?<br>        由于需求不同，Java 就提供了不同的集合类。这多个集合类的数据结构不同，但是它们都是要提供存储和遍历功能的，<br>        我们把它们的共性不断的向上提取，最终就形成了集合的继承体系结构图。</p>
<pre><code>    Collection
        |--List
            |--ArrayList
            |--Vector
            |--LinkedList
        |--Set
            |--HashSet
            |--LinkedHashSet
Collection 的功能概述
        boolean add(Object e) 把给定的对象添加到当前集合中 
</code></pre><p>            void clear() 清空集合中所有的元素<br>            boolean remove(Object o) 把给定的对象在当前集合中删除<br>            boolean contains(Object o) 判断当前集合中是否包含给定的对象<br>            boolean isEmpty() 判断当前集合是否为空<br>            Iterator iterator() 迭代器，用来遍历集合中的元素的<br>            int size() 返回集合中元素的个数<br>            Object[] toArray() 把集合中的元素，存储到数组中<br>    迭代器<br>        A:是集合的获取元素的方式。<br>        B:是依赖于集合而存在的。<br>        C:迭代器的原理和源码。<br>            a:为什么定义为了一个接口而不是实现类?<br>            b:看了看迭代器的内部类实现。<br>    Collection集合的案例(遍历方式 迭代器)<br>        集合的操作步骤：<br>            A:创建集合对象<br>            B:创建元素对象<br>            C:把元素添加到集合<br>            D:遍历集合</p>
<pre><code>    A:存储字符串并遍历
        import java.util.Collection;
        import java.util.ArrayList;
        import java.util.Iterator;

        public class CollectionDemo {
            public static void main(String[] args) {
                //创建集合对象
                Collection c = new ArrayList();

                //创建并添加元素
                c.add(&quot;hello&quot;);
                c.add(&quot;world&quot;);
                c.add(&quot;java&quot;);

                //遍历集合
                Iterator it = c.iterator();
                while(it.hasNext()) {
                    String s =(String) it.next();
                    System.out.println(s);
                }
            }
        }

    B:存储自定义对象并遍历
        public class Student {
            private String name;
            private int age;

            public Student(){}

            public Student(String name,int age) {
                this.name = name;
                this.age = age;
            }

            //getXxx()/setXxx()
        }

        import java.util.Collection;
        import java.util.ArrayList;
        import java.util.Iterator;

        public class StudentDemo {
            public static void main(String[] args) {
                //创建集合对象
                Collection c = new ArrayList();

                //创建学生对象
                Student s1 = new Student(&quot;林青霞&quot;,27);
                Student s2 = new Student(&quot;风清扬&quot;,30);
                Student s3 = new Student(&quot;刘意&quot;,30);
                Student s4 = new Student(&quot;武鑫&quot;,25);
                Student s5 = new Student(&quot;刘晓曲&quot;,16);

                //添加元素
                c.add(s1);
                c.add(s2);
                c.add(s3);
                c.add(s4);
                c.add(s5);

                //遍历集合
                Iterator it = c.iterator();
                while(it.hasNext()) {
                    Student s = (Student)it.next();
                    System.out.println(s.getName()+&quot;---&quot;+s.getAge());
                }
            }
        }

泛型概述
    是一种把明确类型的工作推迟到创建对象或者调用方法的时候才去明确的特殊的类型。
格式：
    &lt;数据类型&gt;
    注意：该数据类型只能是引用类型。
好处：
    A:把运行时期的问题提前到了编译期间
    B:避免了强制类型转换
    C:优化了程序设计，解决了黄色警告线问题，让程序更安全
泛型的前世今生
    A:泛型的由来
        Object类型作为任意类型的时候，在向下转型的时候，会隐含一个转型问题
    B:泛型类
    C:泛型方法
    D:泛型接口
    E:泛型高级通配符
        ?
        ? extends E
        ? super E
我们在哪里使用呢?
    一般是在集合中使用。
</code></pre><p>——————–集合第二天—————————————<br>集合(List)<br>    (1)List是Collection的子接口<br>        特点：有序(存储顺序和取出顺序一致)，可重复。<br>    (2)List的特有功能：<br>        A:添加功能  add(int index, Object e)：向集合指定索引处，添加指定的元素，原有元素依次后移<br>        B:删除功能    remove(int index)：将指定索引处的元素，从集合中删除，返回值为被删除的元素<br>        C:获取功能  get(int index)：获取指定索引处的元素，并返回该元素<br>        D:迭代器功能   listIterator()<br>        E:修改功能     set(int index, Object e)：将指定索引处的元素，替换成指定的元素，<br>                         返回值为替换前的元素<br>    (3)List集合的特有遍历功能<br>        A:由size()和get()结合。<br>        B:代码演示<br>            //创建集合对象<br>            List list = new ArrayList();<br>            //创建并添加元素<br>            list.add(“hello”);<br>            list.add(“world”);<br>            list.add(“java”);</p>
<pre><code>        //遍历集合
        Iterator it = list.iterator();
        while(it.hasNext()) {
            String s =(String) it.next();
            System.out.println(s);
        }
        System.out.println(&quot;----------&quot;);

        for(int x=0; x&lt;list.size(); x++) {
            String s =(String) list.get(x);
            System.out.println(s);
        }
(4)列表迭代器的特有功能；(了解)
    可以逆向遍历，但是要先正向遍历，所以无意义，基本不使用。
(5)并发修改异常
    A:出现的现象
        迭代器遍历集合，集合修改集合元素
    B:原因
        迭代器是依赖于集合的，而集合的改变迭代器并不知道。
    C:解决方案
        a:迭代器遍历，迭代器修改(ListIterator)
            元素添加在刚才迭代的位置
        b:集合遍历，集合修改(size()和get())
            元素添加在集合的末尾
(6)常见数据结构
    A:栈 先进后出
    B:队列 先进先出
    C:数组 查询快，增删慢
    D:链表 查询慢，增删快
(7)List的子类特点(面试题)
    ArrayList
        底层数据结构是数组，查询快，增删慢。
        线程不安全，效率高。
    Vector
        底层数据结构是数组，查询快，增删慢。
        线程安全，效率低。
    LinkedList(特有功能 跟 头尾相关)
        底层数据结构是链表，查询慢，增删快。
        线程不安全，效率高。

    到底使用谁呢?看需求?
    分析：
        要安全吗?
            要：Vector(即使要，也不使用这个，后面再说)
            不要：ArrayList或者LinkedList
                查询多；ArrayList
                增删多：LinkedList

    什么都不知道，就用ArrayList。
</code></pre><p> Set集合(理解)<br>    (1)Set集合的特点<br>        无序,唯一<br>    (2)HashSet集合(掌握)<br>        A:底层数据结构是哈希表(是一个元素为链表的数组)<br>        B:哈希表底层依赖两个方法：hashCode()和equals()<br>          执行顺序：<br>            首先比较哈希值是否相同<br>                相同：继续执行equals()方法<br>                    返回true：元素重复了，不添加<br>                    返回false：直接把元素添加到集合<br>                不同：就直接把元素添加到集合<br>        C:如何保证元素唯一性的呢?<br>            由hashCode()和equals()保证的<br>        D:开发的时候，代码非常的简单，自动生成即可。<br>        E:HashSet存储字符串并遍历<br>        F:HashSet存储自定义对象并遍历(对象的成员变量值相同即为同一个元素)    </p>
<p>针对Collection集合我们到底使用谁呢?(掌握)<br>      唯一吗?<br>         是：Set<br>            HashSet<br>        如果你知道是Set，但是不知道是哪个Set，就用HashSet。<br>        否：List<br>            ArrayList或者LinkedList<br>                    查询多：ArrayList<br>                    增删多：LinkedList<br>        如果你知道是List，但是不知道是哪个List，就用ArrayList。</p>
<pre><code>如果你知道是Collection集合，但是不知道使用谁，就用ArrayList。

如果你知道用集合，就用ArrayList。
</code></pre><p>   在集合中常见的数据结构(掌握)<br>    ArrayXxx:底层数据结构是数组，查询快，增删慢<br>    LinkedXxx:底层数据结构是链表，查询慢，增删快<br>    HashXxx:底层数据结构是哈希表。依赖两个方法：hashCode()和equals()</p>
<p>——————–集合第三天—————————————<br>1:Map<br>    (1)将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。<br>    (2)Map和Collection的区别?<br>        A:Map 存储的是键值对形式的元素，键唯一，值可以重复。夫妻对<br>        B:Collection 存储的是单独出现的元素，子接口Set元素唯一，子接口List元素可重复。光棍<br>    (3)Map接口功能概述<br>        A:添加功能  V put(K key, V value)  把指定的键与指定的值添加到Map集合中<br>        B:删除功能  V remove(Object key) 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值<br>        C:判断功能   boolean containsKey(Object key) 判断集合中是否包含此键<br>                     boolean containsValue(Object value) 判断集合中是否包含此值<br>        D:获取功能  V get(Object key) 根据指定的键，在Map集合中获取对应的值<br>        E:长度功能  size()<br>    (4)Map集合的遍历<br>        A:键找值<br>            a:获取所有键的集合<br>            b:遍历键的集合,得到每一个键<br>            c:根据键到集合中去找值</p>
<pre><code>    B:键值对对象找键和值
        a:获取所有的键值对对象的集合
        b:遍历键值对对象的集合，获取每一个键值对对象
        c:根据键值对对象去获取键和值

    代码体现：
        Map&lt;String,String&gt; hm = new HashMap&lt;String,String&gt;();

        hm.put(&quot;it002&quot;,&quot;hello&quot;);
        hm.put(&quot;it003&quot;,&quot;world&quot;);
        hm.put(&quot;it001&quot;,&quot;java&quot;);

        //方式1 键找值
        Set&lt;String&gt; set = hm.keySet();
        for(String key : set) {
            String value = hm.get(key);
            System.out.println(key+&quot;---&quot;+value);
        }

        //方式2 键值对对象找键和值
        Set&lt;Map.Entry&lt;String,String&gt;&gt; set2 = hm.entrySet();
        for(Map.Entry&lt;String,String&gt; me : set2) {
            String key = me.getKey();
            String value = me.getValue();
            System.out.println(key+&quot;---&quot;+value);
        }
(5)HashMap集合的练习
    A:HashMap&lt;String,String&gt;
    B:HashMap&lt;Integer,String&gt;
    C:HashMap&lt;String,Student&gt;
    D:HashMap&lt;Student,String&gt;
(5)练习
    A:统计一个字符串中每个字符出现的次数
    &quot;aebbeda&quot;
      可能要用到的方法  
             V put(K key, V value)
             boolean containsKey(Object key) 判断集合中是否包含此键
             V get(Object key) 根据指定的键，在Map集合中获取对应的值
</code></pre><p>2:Collections<br>    (1)是针对集合进行操作的工具类<br>    (2)面试题：Collection和Collections的区别<br>        A:Collection 是单列集合的顶层接口，有两个子接口List和Set<br>        B:Collections 是针对集合进行操作的工具类，可以对集合进行排序和查找等<br>    (3)常见的几个小方法：<br>        A:public static <t> void sort(List<t> list)<br>        B:public static void shuffle(List&lt;?&gt; list)<br>    (4)案例<br>        模拟斗地主洗牌和发牌并对牌进行排序</t></t></p>
<p>——————–IO第一天  File 类———————————-<br> File 对应的  是 计算机中的 文件或文件夹<br> 需要知道 文件或文件夹的 抽象路径<br>    1:构造方法  3个<br>      File(String pathname) √<br>            根据  路径 的字符串  封装一个File对象<br>      File(String parent, String child)<br>            根据 父路径和子路径 字符串  封装一个File对象<br>      File(File parent, String child)<br>            根据 父目录file对象和子路径字符串  封装成一个File对象</p>
<pre><code>  绝对路径:  带盘符
  相对路径:  不带盘符   跟项目相对的路径
2:创建功能 
  public boolean createNewFile() 创建新的文件
  public boolean mkdir() 创建新的文件夹
  public boolean mkdirs() 创建多级文件夹
3:删除功能
  public boolean delete() 删除比较暴力 谨慎使用 基本不用
4:判断功能
  public boolean isFile() 判断这个对象是否是文件   √
  public boolean isDirectory() 判断这个对象是否是目录   √
  public boolean exists() 判断这个对象对应的路径 是否真实存在
5:获取功能
  public String getName() 获取文件或文件夹名称   √
  public long length()  获取文件或文件夹大小 
  public String getAbsolutePath() 获取绝对路径   √
  public String getPath() 获取封装对象的 那个抽象路径
  public long lastModified() 获取最后一次修改时间
6:高级获取功能 
  public String[] list() 获取目录下的所有文件或文件夹的名字以字符串数组形式存储
  √ public File[] listFiles() 获取目录下 所有的文件或文件夹,它们以对象形式存储到数组中
  √ public File[] listFiles(FileFilter filter) 获取目录下的所有的文件或文件夹,只将符合条件的存储到File数组中

  递归 
   发现 你的程序里  方法自己调用自己  
                     递归   直接递归 间接递归

   那个递归使用图解看一下  阶乘的 
    注意事项: 
        递归一定有出口  否则程序停不下来
        递归次数不要太多 太多就内存溢出
        构造方法  禁止使用递归
</code></pre><p>————————IO流第二天————————–<br>文件:<br>   文本文件  字符   字符流<br>   其他字节码文件   字节流<br>O:out  输出  write<br>  OutputStream : 字节输出流抽象父类<br>       |–FileOutputStream  可以操作文件的  将程序中的数据写到文件File中<br>         构造: FileOutputStream(File file)<br>               FileOutputStream(String pathname) 如果文件不存在可以帮忙创建出来<br>         写数据:<br>               write重载<br>                    写单个字节  一个字节一个字节<br>                    写字节数组<br>                    写字节数组一部分<br>         关闭流:<br>              close()<br>I:in 输入  读  read<br>  InputStream : 字节输入流抽象父类<br>       |–FileInputStream 可以操作文件的 字节输入流  将文件中的数据读取到内存中<br>         构造: FileInputStream(File file)<br>               FileInputStream(String pathname)<br>         读数据<br>               int read() 读取一个字节  返回值是 那个字节 只不过用int接收<br>                          如果读到了末尾,返回-1<br>               int read(byte[] bys) 按照一个字节数组的量去读取,返回值是读取到字节的个数,<br>                                    如果读到末尾,返回-1<br>                                    byte[]  0, length<br>               还有一个方法可以读取字节数组的一部分<br>          关闭流:<br>             close();<br>字符流:<br>    常见编码表(现在作为了解)<br>     常用的编码表   GBK  UTF-8   拉丁码表(不能识别中文)<br>                    GBK:英文占一个字节  中文占两个  \r \n<br>                    UTF-8:能用一个字节的就用一个  中文占3个<br>                    咱们现在默认的是GBK<br>    编码: 将看得懂的变成看不懂的             地下党–发密文<br>          字符—数字       输出流<br>    解码: 将看不懂的变成看的懂得             我党–解读密文<br>          数字–字符        输入流<br>Reader 字符输入流的抽象父类<br>       |–FileReader 操作文件的字符输入流<br>         构造 FileReader(File file)<br>              FileReader(String pathname)<br>         读取:<br>             int read() 一个字符一个字符读取 返回值是读到的字符 还是用int来接收<br>                        如果读不到  返回-1<br>             int read(char[] chs) 使用字符数组读取 将读取到的字符放在数组中,返回值就是读到的字符个数<br>             可以读取字符数组的一部分<br>         关闭流<br>            close()<br>Writer 字符输出流的抽象父类<br>       |–FileWriter 操作文件的字符输出流<br>          构造 FileWriter(File file)<br>               FileWriter(String pathname)<br>          写<br>            write重载  写单个字符<br>                       写字符数组<br>                       写字符串<br>                       写字符数组一部分<br>                       写字符串一部分<br>          关闭流:<br>            close()  先刷新再关闭流<br>            flush()  将数据刷新到文件中</p>
<p>读文件 写文件<br>    1:创建对应的流<br>    2:做对应的操作<br>    3:关闭流<br>复制文件:<br>    1:创建输入流 跟 数据源文件关联<br>    2:创建输出流 跟 目标文件冠梁<br>    3:从数据源中读数据<br>    4:往目标文件写数据<br>    5:关闭流</p>
<p>————————IO流第三天————————–<br>转换流和子类区别<br>发现有如下继承关系：<br>OutputStreamWriter:<br>        |–FileWriter:<br>InputStreamReader:<br>        |–FileReader;</p>
<p>父类和子类的功能有什么区别呢？<br>OutputStreamWriter和InputStreamReader是字符和字节的桥梁：也可以称之为字符转换流。<br>字符转换流原理：字节流+编码表。<br>FileWriter和FileReader：作为子类，仅作为操作字符文件的便捷类存在。<br>当操作的字符文件，使用的是默认编码表时可以不用父类，而直接用子类就完成操作了，简化了代码。<br>InputStreamReader isr = new InputStreamReader(new FileInputStream(“a.txt”));//默认字符集。<br>InputStreamReader isr = new InputStreamReader(new FileInputStream(“a.txt”),”GBK”);//指定GBK字符集。<br>FileReader fr = new FileReader(“a.txt”);<br>这三句代码的功能是一样的，其中第三句最为便捷。</p>
<p>注意：一旦要指定其他编码时，绝对不能用子类，必须使用字符转换流。</p>
<p>什么时候用子类呢？<br>条件：<br>1、操作的是文件。2、使用默认编码。<br>总结：<br>字节—&gt;字符 ： 看不懂的—&gt;看的懂的。  需要读。输入流。 InputStreamReader<br>字符—&gt;字节 ： 看的懂的—&gt;看不懂的。  需要写。输出流。 OutputStreamWriter</p>
<p>缓冲流  :<br>在我们学习字节流与字符流的时候，大家都进行过读取文件中数据的操作，<br>读取数据量大的文件时，读取的速度会很慢，很影响我们程序的效率，那么，我想提高速度，怎么办？<br>Java中提高了一套缓冲流，它的存在，可提高IO流的读写速度<br>缓冲流，根据流的分类分类字节缓冲流与字符缓冲流。<br>缓冲流 就是 对基本的字符流或者字节流 进行了一层包装<br>也就是 在构造中 BufferedXxxx(传递对应的字节流或者字符流)<br>                    注意 我们学习的字节流 子类 有  FileInputStream FileOutputStream<br>                         我们学习的字符流 子类 有  FileReader  FileWriter<br>                                                   InputStreamReader OutputStreamWriter</p>
<p>缓冲流就是加了一层包装 在调用方法上都是一样的<br>只不过 在 BufferedReader 中有读取一行的方法  readLine()<br>       在 BufferedWriter 中有写一个换行操作的方法  newLine()</p>
<p>————-流的操作规律————————-<br>IO流中对象很多，解决问题(处理设备上的数据时)到底该用哪个对象呢？　　<br>把IO流进行了规律的总结(四个明确)：<br>        明确一：要操作的数据是数据源还是数据目的。<br>                源： InputStream    Reader<br>                目的： OutputStream Writer<br>        先根据需求明确要读，还是要写。</p>
<pre><code>明确二：要操作的设备上的数据是字节还是文本呢？
        源：
            字节： InputStream
            文本： Reader
        目的：
            字节： OutputStream
            文本： Writer
已经明确到了具体的体系上。

明确三：明确数据所在的具体设备。
        源设备：
            硬盘：文件  File开头。
            内存：数组，字符串。
            键盘：System.in;
            网络：Socket
        目的设备：
            硬盘：文件  File开头。
            内存：数组，字符串。
            屏幕：System.out
            网络：Socket
完全可以明确具体要使用哪个流对象。

明确四：是否需要额外功能呢？
        额外功能：
            转换吗？转换流。InputStreamReader OutputStreamWriter
            高效吗？缓冲区对象。BufferedXXX
</code></pre><h2 id="————————IO流第四天————————–"><a href="#————————IO流第四天————————–" class="headerlink" title="————————IO流第四天————————–"></a>————————IO流第四天————————–</h2><p>###—————————io特殊的使用方式———————————-<br>Properties：Map集合的一种，它是Hashtable集合的子集合,它键与值都是String类型,</p>
<pre><code>它是唯一能与IO流结合使用的集合
</code></pre><p>方法<br>load( InputStream in ) 从流所对应的文件中，读数据到集合中<br>load( Reader in ) 从流所对应的文件中，读数据到集合中<br>store( OutputStream out , String message ) 把集合中的数据，写入到流所对应的文件中<br>store( Writer out , String message) 把集合中的数据，写入到流所对应的文件中</p>
<p>实现文件内容的自动追加<br>构造方法<br>    FileOutputStream(File file, boolean append)<br>    FileOutputStream(String fileName, boolean append)<br>    FileWriter(File, boolean append)<br>    FileWriter(String fileName, boolean append)<br>Commons-IO<br>    FileUtils  工具类<br>    readFileToString(File file)：读取文件内容，并返回一个String；<br>    writeStringToFile(File file，String content)：将内容content写入到file中；<br>    copyDirectoryToDirectory(File srcDir,File destDir);文件夹复制<br>    copyFileToFile(File srcFile,File destFile);文件夹复制<br>————————-流的总结————————————-<br>字节流<br>    字节输入流 InputStream<br>     FileInputStream  操作文件的字节输入流<br>     BufferedInputStream 高效的字节输入流<br>     ObjectInputStream 反序列化流<br>    字节输出流   OutputStream<br>     FileOutputStream  操作文件的字节输出流<br>     BufferedOutputStream 高效的字节输出流<br>       ObjectOutputStream  序列化流<br>字符流<br>  字符输入流 Reader<br>      FileReader 操作文件的字符输入流<br>      BufferedReader 高效的字符输入流<br>      InputStreamReader 输入操作的转换流(把字节流封装成字符流)<br>  字符输出流 Writer<br>      FileWriter 操作文件的字符输出流<br>      BufferedWriter 高效的字符输出流<br>      OutputStreamWriter 输出操作的转换流(把字节流封装成字符流)</p>
<p>方法：<br>    读数据方法：<br>        read() 一次读一个字节或字符的方法<br>        read(byte[]  char[]) 一次读一个数组数据的方法<br>      readLine() 一次读一行字符串的方法(BufferedReader类特有方法)<br>      readObject() 从流中读取对象(ObjectInputStream特有方法)<br>写数据方法：<br>        write(int) 一次写一个字节或字符到文件中<br>        write(byte[] char[]) 一次写一个数组数据到文件中<br>        write(String) 一次写一个字符串内容到文件中<br>        writeObject(Object ) 写对象到流中(ObjectOutputStream类特有方法)<br>        newLine() 写一个换行符号(BufferedWriter类特有方法)<br>向文件中写入数据的过程<br>        1，创建输出流对象<br>        2，写数据到文件<br>        3，关闭输出流<br>从文件中读数据的过程<br>        1，创建输入流对象<br>        2，从文件中读数据<br>        3，关闭输入流</p>
<p>文件复制的过程<br>        1，创建输入流（数据源）<br>        2，创建输出流（目的地）<br>        3，从输入流中读数据<br>        4，通过输出流，把数据写入目的地<br>        5，关闭流</p>
<p>———————–多线程————————<br>概念:<br>  进程:正在运行的程序<br>  线程:程序的执行路径</p>
<p>  一个进程中有一个或多个线程,CPU执行程序 以线程为单位.</p>
<p>  线程的调度方法:<br>      java采用的是抢占式线程调度方式.</p>
<pre><code>CPU超高速运行,HZ  每秒脉冲数,频率.  1GHz   10亿赫兹 
</code></pre><p>创建线程的方式(需要掌握)<br>方式1，继承Thread线程类<br>步骤<br>        1，自定义类继承Thread类<br>        2，在自定义类中重写Thread类的run方法<br>        3，创建自定义类对象(线程对象)<br>        4，调用start方法，启动线程，通过JVM，调用线程中的run方法<br>方式2，实现Runnable接口<br>步骤<br>        1，创建线程任务类 实现Runnable接口<br>        2，在线程任务类中 重写接口中的run方法<br>        3，创建线程任务类对象<br>        4，创建线程对象，把线程任务类对象作为Thread类构造方法的参数使用<br>        5，调用start方法，启动线程，通过JVM，调用线程任务类中的run方法</p>
<p>  这两种方式 那个更好<br>    第二种<br>    将线程执行任务(目标)和线程对象本身进行分离<br>    方便数据共享<br>    突破了单继承局限性</p>
<pre><code>多个线程  可以  做同一个任务  线程安全问题 共享数据的安全问题
出现的前提:(抢占式操作带来的安全问题)
    多个线程 
    多个线程有共享数据
    多个线程操作共享数据

处理方式: 加锁              (使用同步代码块的方式处理卖票的安全问题)
   同步代码块:多个线程必须使用同一把锁
     synchronized (锁对象){ 
         可能出现问题的代码;
     }
   同步方法: 将可能出现安全问题的代码 放到一个方法中  这个方法被synchronized修饰
     public synchronized void 方法名(){
             可能出现问题的代码;
     }
     锁对象this

   静态的同步方法:  锁对象  类名.class
       public static synchronized void 方法名(){
             可能出现问题的代码;
     }
     JDK1.5之后  Lock 接口  表示锁
     lock() 加锁
     unlock() 解锁 


     Thread 
        静态
            static void sleep(long time) 休眠多长时间  属于阻塞状态  放弃了CPU执行资格  放弃CPU执行权  
            static Thread currentThread() 获取正在运行的线程对象

        非静态
            setName(String name) 给线程设置名字
            getName() 获取线程名字
            start() 开启线程 

   跟线程相关的三个方法  定义在Object中  
        wait() 让当前正在执行的线程  等待 进入阻塞状态  放弃了CPU执行资格  放弃CPU执行权 
        notify() 让在等待的线程 唤醒   唤醒一个  随机 
        notifyAll() 将所有的等待线程 唤醒 

        这三个方法  是锁对象调用 

   线程中通信  
         等待唤醒机制  (了解)

   线程中的几个状态 

      创建状态   刚创建 线程
      就绪状态   线程具备了执行资格  而没有执行权
      阻塞状态   线程没有执行资格   也没有执行权
      运行状态   线程有执行资格  有执行权
      消亡状态   挂掉了,等待收尸 
</code></pre><p>————网络编程——————-</p>
<p>ip<br>端口号<br>UDP<br>  特点: 传输块,容易丢数据<br>   聊天室<br>TCP<br>  特点:  传输稳定,数据安全<br>  上传,下载</p>
<p>UDP  TCP操作过程 知道了 </p>
<p>UDP 发送端和接收端  </p>
<p>TCP 客户端 和 服务器端</p>
<p>——————–反射 作为了解知识点 看看使用步骤就行————————-<br>如何获取.Class文件对象<br>        1, 通过Object类 getClass()方法获取 Class对象<br>        2, 通过类名.class 方式 获取 Class对象<br>        3, 通过反射的方式, Class.forName(String classname) 获取Class对象<br>            public static Class&lt;?&gt; forName(String className)throws ClassNotFoundException<br>返回与带有给定字符串名的类或接口相关联的 Class 对象</p>
<p>通过反射， 获取类中的构造方法，并完成对象的创建<br>        获取指定的构造方法<br>              public Constructor<t> getConstructor(Class&lt;?&gt;… parameterTypes)<br>                获取指定的public修饰的构造方法<br>              public Constructor<t> getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)<br>                获取指定的构造方法，包含私有的<br>          获取所有的构造方法<br>              public Constructor&lt;?&gt;[] getConstructors() 获取所有的public 修饰的构造方法<br>              public Constructor&lt;?&gt;[] getDeclaredConstructors() 获取所有的构造方法，包含私有的</t></t></p>
<p>通过反射， 获取类中的构造方法，并完成对象的创建<br>          步骤：<br>          1，获取字节码文件对象<br>          2,通过字节码文件对象 ，获取到指定的构造方法<br>              getConstructor(参数);<br>          3,通过构造方法，创建对象<br>              public T newInstance(Object… initargs)</p>
<p>私有构造方法，创建对象<br>        1，获取字节码文件对象<br>          2,通过字节码文件对象 ，获取到指定的构造方法<br>              getDeclaredConstructor (参数);<br>          3,暴力访问<br>              con.setAccessible(true);<br>          4,通过构造方法，创建对象<br>              public T newInstance(Object… initargs)</p>
<p>通过反射，获取Class文件中的方法<br>          获取指定的方法<br>              public Method getMethod(String name, Class&lt;?&gt;… parameterTypes)<br>                  获取指定的public方法<br>              public Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)<br>                  获取指定的任意方法，包含私有的<br>          获取所有的方法<br>              public Method[] getMethods() 获取本类与父类中所有public 修饰的方法<br>              ublic Method[] getDeclaredMethods()获取本类中所有的方法，包含私有的<br>​<br>通过反射，调用方法<br>      步骤：<br>      1，获取Class对象<br>      2,获取构造方法，创建对象<br>      3,获取指定的public方法<br>      4,执行方法<br>          public Object invoke(Object obj, Object… args)</p>
<p>私有方法的调用：<br>     1，获取Class对象<br>     2,获取构造方法，创建对象<br>     3,获取指定的private方法<br>     4,开启暴力访问<br>         m5.setAccessible(true);<br>     5,执行方法<br>         public Object invoke(Object obj, Object… args)</p>
<p>通过反射，获取成员变量(字段)<br>          获取指定的成员变量<br>               public Field getField(String name) 获取public修饰的成员变量<br>               public Field getDeclaredField(String name) 获取任意的成员变量，包含私有<br>          获取所有的成员变量<br>               public Field[] getFields() 获取所有public修饰的成员变量<br>               public Field[] getDeclaredFields() 获取司所有的成员变量，包含私有</p>
<p>通过反射，获取成员 变量，并赋值使用<br>          步骤：<br>          1，获取字节码文件对象<br>          2,获取构造方法，创建对象<br>          3,获取指定的成员变量<br>          4,对成员变量赋值\获取值操作<br>              public void set(Object obj,  Object value) 赋值<br>              public Object get(Object obj) 获取值</p>
<p>私有成员变量的使用<br>           步骤：<br>          1，获取字节码文件对象<br>          2,获取构造方法，创建对象<br>          3,获取指定的成员变量<br>          4,开启暴力访问<br>          5,对成员变量赋值\获取值操作<br>              public void set(Object obj,  Object value) 赋值<br>              public Object get(Object obj) 获取值</p>
<p>——————-数据库———————<br>操作mysql数据库 最主要的事情 就是进行表中数据的增删改查</p>
<p>CREATE DATABASE day29;<br>USE day29;<br>CREATE TABLE car(<br> id INT PRIMARY KEY AUTO_INCREMENT, #ID<br> cname VARCHAR(20), #车型名称<br> company VARCHAR(20), #厂商<br> address varchar(20), #产地<br> grade VARCHAR(20), #级别<br> price DOUBLE #价格(万元)<br>);<br>主键 的约束<br>    非空  唯一<br>增加(插入)记录<br>  insert into 表 (列名1,列名2,列名3..) values  (值1,值2,值3..);<br>  – 向表中插入某些列  插入指定的列<br>  insert into car(address,cname)values(‘中国’,’破天520’);<br>  insert into 表 values (值1,值2,值3..); –向表中插入所有列<br>更新(修改)记录<br>  update 表名 set 字段名=值,字段名=值;<br>  update 表名 set 字段名=值,字段名=值 where 条件;<br>删除表记录<br>   delete from 表名 [where 条件];</p>
<p>删除表中所有记录使用delete from 表名; 还是用truncate table 表名;<br>删除方式：delete 一条一条删除，不清空auto_increment记录数。<br>truncate 直接将表删除，重新建表，auto_increment将置为零，从新开始。</p>
<p>查询<br>select [distinct]*[列名,列名] from 表 [where 条件].</p>
<p>JAVA    DataBase  Connection</p>
<p>JDBC<br>JAVA<br>   Driver接口 </p>
<p>   mysql —Driver</p>
<p>   导包 mysql-connector-java-5.1.37-bin.jar<br>JDBC套路<br>    注册驱动<br>    Class.forName(“com.mysql.jdbc.Driver”);<br>    获取连接<br>    Connection conn = DriverManager.getConnection(url,username,password);<br>    获取sql语句执行者<br>    Statement state = conn.createStatement();<br>    String sql=”略”;<br>    state根据 语句执行<br>       int executeUpdate(String sql); –执行insert update delete语句.<br>       ResultSet executeQuery(String sql); –执行select语句.<br>    如果执行了查询语句 那么肯定有结果集<br>         处理结果集<br>         rs.next();//光标移动到第一行<br>         rs.getXxx(1);//获取第一行第一列的数据</p>
<pre><code> rs.getXxx(字段名) //获取莫一行上 某个字段对应的值
   while(rs.next()){
      rs.getXxx(..);
   }
关闭资源 
  结果集 ,执行者 ,连接
</code></pre><p>   预处理对象<br>    String sql = “insert into category(cid,cname) values(?,?)”;<br>    PreparedStatement预处理对象代码：PreparedStatement psmt = conn.prepareStatement(sql)<br>    将? 用实际的参数替代掉<br>    int executeUpdate(); –执行insert update delete语句.<br>  ResultSet executeQuery(); –执行select语句.</p>
<p>——————-DBUtils——————————-<br>DBUtils 简化JDBC工具包  简化了开发步骤<br>  核心类  QueryRunner 类  封装了操作数据库API<br>          ResultSetHandler 结果处理集<br>          DbUtils 工具类   释放资源以及事务处理</p>
<p>  DBUtils完成增删改<br>      1:创建QueryRunner对象<br>      2:写sql语句  执行<br>       update(连接对象,sql语句,参数)<br>      3:影响多少行<br>  DBUtils完成查询<br>      1:创建QueryRunner对象<br>      2:写sql语句 执行<br>      3:选择结果处理集(接口的实现类) 6种 </p>
<pre><code>ArrayHandler:将第一条记录封装到Object数组中,数组中的元素是该记录的字段值
ArrayListHandler:将每一条记录封装到Object数组中,数组中的元素是该记录的字段值
                 将多个数组放到List集合中
BeanHandler: 将第一条记录封装到指定的JavaBean对象中 
BeanListHander:将每一条记录封装到指定的JavaBean对象中,多个对象放在List集合中 
ColumnListHandler:将指定列的值放到List集合中
ScalarHandler:获取单数据    count----Long
</code></pre><p>rrayHandler：将结果集中的第一条记录封装到一个Object[]数组中，数组中的每一个元素就是这条记录中的每一个字段的值<br>public class ArrayHandlerDemo {<br>​<br>    @Test<br>    public void method(){<br>        try {<br>            //获取QueryRunner对象<br>            QueryRunner qr = new QueryRunner();<br>            //执行SQL语句<br>            String sql = “SELECT * FROM zhangwu”;<br>            Object[] params = {};<br>            Connection conn = JDBCUtils.getConnection();<br>            Object[] objArray = qr.query(conn, sql, new ArrayHandler(), params);<br>            //结果集的处理<br>            System.out.println( Arrays.toString(objArray) );</p>
<pre><code>        conn.close();
    } catch (SQLException e) {
        e.printStackTrace();
    }
}
</code></pre><p>}</p>
<p>ArrayListHandler：将结果集中的每一条记录都封装到一个Object[]数组中，将这些数组在封装到List集合中。<br>public class ArrayListHandlerDemo {<br>    @Test<br>    public void method(){<br>        try {<br>            //获取QueryRunner对象<br>            QueryRunner qr = new QueryRunner();<br>            //执行SQL语句<br>            String sql = “SELECT * FROM zhangwu WHERE money&gt;?”;<br>            Object[] params = {2000};<br>            Connection conn = JDBCUtils.getConnection();<br>             List<object[]> list = qr.query(conn, sql, new ArrayListHandler(), params);<br>            //结果集的处理<br>             for (Object[] objArray : list) {<br>                System.out.println(  Arrays.toString(objArray) );<br>            }</object[]></p>
<pre><code>        conn.close();
    } catch (SQLException e) {
        e.printStackTrace();
    }
}
</code></pre><p>}</p>
<p>BeanHandler    ：将结果集中第一条记录封装到一个指定的javaBean中。<br>public class BeanHandlerDemo {<br>    @Test<br>    public void method(){<br>        try{<br>            //获取QueryRunner<br>            QueryRunner qr = new QueryRunner();<br>            //执行SQL语句<br>            String sql = “SELECT * FROM zhangwu WHERE id=?”;<br>            Object[] params = {1};<br>            Connection conn = JDBCUtils.getConnection();<br>            ZhangWu zw = qr.query(conn, sql, new BeanHandler<zhangwu>(ZhangWu.class), params);<br>            //结果集处理<br>            System.out.println(zw);</zhangwu></p>
<pre><code>        conn.close();
    } catch(SQLException e){
        throw new RuntimeException(e);
    }
}
</code></pre><p>}</p>
<p>BeanListHandler    ：将结果集中每一条记录封装到指定的javaBean中，将这些javaBean在封装到List集合中<br>public class BeanListHandlerDemo {<br>    @Test<br>    public void method(){<br>        try{<br>            //获取QueryRunner<br>            QueryRunner qr = new QueryRunner();<br>            //执行SQL语句<br>            String sql = “SELECT * FROM zhangwu WHERE money&gt;?”;<br>            Object[] params = {2000};<br>            Connection conn = JDBCUtils.getConnection();<br>            List<zhangwu> list = qr.query(conn, sql, new BeanListHandler<zhangwu>(ZhangWu.class), params);<br>            //结果集处理<br>            for (ZhangWu zw : list) {<br>                System.out.println(zw);<br>            }</zhangwu></zhangwu></p>
<pre><code>        conn.close();
    } catch(SQLException e){
        throw new RuntimeException(e);
    }
}
</code></pre><p>}<br>ColumnListHandler：将结果集中指定的列的字段值，封装到一个List集合中<br>public class ColumnListHandlerDemo {<br>    @Test<br>    public void method(){<br>        try {<br>            //获取QueryRunner对象<br>            QueryRunner qr = new QueryRunner();<br>            //执行SQL语句<br>            String sql = “SELECT name FROM zhangwu WHERE money&gt;?”;<br>            Object[] params = {2000};<br>            Connection conn = JDBCUtils.getConnection();<br>            List<string> list = qr.query(conn, sql, new ColumnListHandler<string>(), params);<br>            //结果集的处理<br>            for (String str : list) {<br>                System.out.println(str);<br>            }</string></string></p>
<pre><code>        conn.close();
    } catch (SQLException e) {
        e.printStackTrace();
    }
}
</code></pre><p>}</p>
<p>ScalarHandler：它是用于单数据。例如select count(*) from 表操作。<br>public class ScalarHandlerDemo {<br>    @Test<br>    public void method(){<br>        try {<br>            //获取QueryRunner对象<br>            QueryRunner qr = new QueryRunner();</p>
<pre><code>        //执行SQL语句
        String sql = &quot;SELECT MAX(money) FROM zhangwu&quot;;
        Object[] params = {};
        Connection conn = JDBCUtils.getConnection();
        Double max = qr.query(conn, sql, new ScalarHandler&lt;Double&gt;(), params);
        //结果集的处理
        System.out.println(&quot;max=&quot; + max);

        conn.close();
    } catch (SQLException e) {
        e.printStackTrace();
    }
}
</code></pre><p>}</p>
<p>——————-连接池———————–<br>DBCP连接池<br>作用：自身维护了多个Connection连接对象维护<br>BasicDataSource类  是  DataSource接口的实现类<br>DataSource接口，它是java与每种数据库连接池 连接的规范标准<br>DBCP连接池常见的配置<br>必须项    driverClassName    数据库驱动名称<br>    url    数据库的地址<br>    username    用户名<br>    password    密码<br>基本项    maxActive    最大连接数量<br>    initialSize    连接池中初始化多少个Connection连接对象<br>扩展项    maxWait    超时等待时间以毫秒为单位 1000等于1秒<br>测试类<br>/*</p>
<ul>
<li><p>演示使用DBUtils工具  完成数据库表的增加操作<br> */<br>public class Demo {<br>// 插入功能<br>@Test<br>public void insert(){</p>
<pre><code>try {
    //获取一个用来执行SQL语句的对象   QueryRunner
    QueryRunner qr = new QueryRunner(JDBCUtils.getDataSource());
</code></pre><p>String sql = “INSERT INTO zhangwu(name,money,parent) VALUES(?,?,?)”;</p>
<pre><code>    Object[] params = {&quot;股票收入&quot;, 5500, &quot;收入&quot;};    
     int line = qr.update(sql,params);
    //结果集处理
    System.out.println(&quot;line = &quot; + line);

} catch (SQLException e) {
    throw new RuntimeException(e);
}
</code></pre><p>}</p>
<p>//删除功能<br>@Test<br>public void delete(){</p>
<pre><code>try {
    //创建一个QueryRunner对象，用来完成SQL语句的执行
    QueryRunner qr = new QueryRunner(JDBCUtils.getDataSource());
    //执行SQL语句
    String sql = &quot;DELETE FROM zhangwu WHERE name = ?&quot;;
    Object[] params = {&quot;股票收入&quot;};
    int line = qr.update(sql, params);
    //结果集的处理
    System.out.println(&quot;line=&quot;+line);

} catch (SQLException e) {
    throw new RuntimeException(e);
}
</code></pre><p>}</p>
<p>//更新功能<br>@Test<br>public void update(){</p>
<pre><code>try {
    //创建一个QueryRunner对象，用来完成SQL语句的执行
    QueryRunner qr = new QueryRunner(JDBCUtils.getDataSource());
    //执行SQL语句
    String sql = &quot;UPDATE zhangwu SET money = money+1000 WHERE name=?&quot;;
    Object[] params = {&quot;股票收入&quot;};
    int line = qr.update(sql, params);
    //结果集的处理
    System.out.println(&quot;line=&quot;+line);

} catch (SQLException e) {
    throw new RuntimeException(e);
}
</code></pre><p>}</p>
<p>//查询功能,将结果集中第一条记录封装到一个指定的javaBean中。<br>@Test<br>public void search(){</p>
<pre><code>try{
    //获取QueryRunner 
    QueryRunner qr = new QueryRunner(JDBCUtils.getDataSource());
    //执行SQL语句
    String sql = &quot;SELECT * FROM zhangwu&quot;;
    Object[] params = {};
    Product p = qr.query(sql, new BeanHandler&lt;Product&gt;(Product.class), params);
    //结果集处理
    System.out.println(p);

} catch(SQLException e){
    throw new RuntimeException(e);
}
</code></pre><p>}<br>}</p>
</li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/04/26/多线程三种创建方式/" rel="next" title="多线程三种创建方式">
                <i class="fa fa-chevron-left"></i> 多线程三种创建方式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/05/10/面向对象三大特征/" rel="prev" title="面向对象">
                面向对象 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="Cuidx" />
          <p class="site-author-name" itemprop="name">Cuidx</p>
           
              <p class="site-description motion-element" itemprop="description">�޵���</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">62</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#————————IO流第四天————————–"><span class="nav-number">1.</span> <span class="nav-text">————————IO流第四天————————–</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cuidx</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
